## 排序算法


### 简介

> 在计算机科学与数学中，一个排序算法（英语：Sorting algorithm）是一种能将一串资料依照特定排序方式进行排列的一种算法。 - [1]

排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。一般来说，我们说的排序算法是针对内存里的数据进行排序，即内部排序。

常见的排序算法

排序方法 | 最优 | 平均 | 最差 | 内存占用 | 是否稳定 | 方法 | 补充 
--- | --- | --- | --- | --- | --- | --- |---
插入排序 | n | n^2 | n^2  | 1 | 是 | 插入 | 比较排序
希尔排序 | nlogn | n^(4/3) | n^(3/2) | 1 | 否 | 插入 | 比较排序
选择排序 | n^2 | n^2 | n^2 | 1 | 否 | 选择 | 比较排序
堆排序 | nlogn | nlogn | nlogn | 1 | 否 | 选择 | 比较排序
冒泡排序 | n | n^2 | n^2  | 1 | 是 | 交换| 比较排序
快速排序 | nlogn | nlogn | n^2 | logn | 否 | 交换与分治| 比较排序 
归并排序 | nlogn | nlogn | nlogn | n | 是 | 合并 | 比较排序
桶排序 | n+k  | n+k | n^2 | n*K | 是 | \ | 非比较排序
计数排序 | n+k  | n+k | n+k | n+k | 是 | 哈希表 | 非比较排序


参考资料：
- [1] [Sorting algorithm](https://en.wikipedia.org/wiki/Sorting_algorithm)

<br>

TODO:
- [x] 插入排序
- [ ] 希尔排序
- [x] 选择排序
- [x] 堆排序
- [x] 冒泡排序
- [x] **快速排序**：递归和非递归方法实现
- [ ] 归并排序
- [ ] 桶排序
- [ ] 计数排序

### 1. 插入排序

一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下 [1]：
- 1.从第一个元素开始，该元素可以认为已经被排序
- 2.取出下一个元素，在已经排序的元素序列中从后向前扫描
- 3.如果该元素（已排序）大于新元素，将该元素移到下一位置
- 4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
- 5.将新元素插入到该位置后
- 6.重复步骤2~5

排序过程如下：
<center>
<img src='resource/sorting/img_01.gif'>
</center>

参考资料：
- [1] [Insertion sort](https://en.wikipedia.org/wiki/Insertion_sort)

<br>

### 2. 希尔排序



<br>

### 3. 选择排序

选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下:
- 1.首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
- 2.再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
- 3.以此类推，直到所有元素均排序完毕

排序过程如下：
<center>
<img src='resource/sorting/img_03.gif' height=250>
</center>

参考资料：
- [1] [Selection sort](https://en.wikipedia.org/wiki/Selection_sort)

<br>

### 4. 堆排序

> 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。 - [1]

算法步骤如下：
- 1.构建最大（小）堆
- 2.将最大（小）堆中取出最大（小）的结点，即根节点与最后一个结点交换，交换后的最后一个结点移出堆
- 3.重新调整剩余数据，保证其维持最大（小）堆的性质
- 4.重复步骤2-3至剩余数据为空

排序过程如下：
<center>
<img src='resource/sorting/img_04.gif'>
</center>

参考资料：
- [1] [Heapsort](https://en.wikipedia.org/wiki/Heapsort)

<br>

### 5. 冒泡排序

冒泡排序算法的运作如下 [1]：
- 1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。
- 2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
- 3.针对所有的元素重复以上的步骤，除了最后一个。
- 4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

排序过程如下：
<center>
<img src='resource/sorting/img_02.gif'>
</center>

参考资料：
- [1] [Bubble sort](https://en.wikipedia.org/wiki/Bubble_sort)

<br>

### 6.快速排序


> 快速排序使用分治法策略来把一个序列分为较小和较大的2个子序列，然后递归地排序两个子序列。 - [1] 

算法步骤为 [1]：
- 1.挑选基准值：从数列中挑出一个元素，称为“基准”（pivot），
- 2.分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。
- 3.递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。

排序过程如下：
<center>
<img src='resource/sorting/img_05.gif'>
</center>

参考资料：
- [1] [Quicksort](https://en.wikipedia.org/wiki/Quicksort)

<br>

### 7.归并排序

> 归并排序（Merge sort），是创建在归并操作上的一种有效的排序算法。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。 - [1]

算法步骤可以分为两种：
（1）递归法（Top-down）
- 1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
- 2.设定两个指针，最初位置分别为两个已经排序序列的起始位置
- 3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
- 4.重复步骤3直到某一指针到达序列尾
- 5.将另一序列剩下的所有元素直接复制到合并序列尾

（2）迭代法（Bottom-up）（假设序列共有 *n* 个元素）
- 1.将序列每相邻两个数字进行归并操作，形成 *ceil(n/2)* 个序列，排序后每个序列包含两/一个元素
- 2.若此时序列数不是1个则将上述序列再次归并，形成 *ceil(n/4)* 个序列，每个序列包含四/三个元素
- 3.重复步骤2，直到所有元素排序完毕，即序列数为1

排序过程如下：
<center>
<img src='resource/sorting/img_06.gif'>
</center>


参考资料：
- [1] [Merge sort](https://en.wikipedia.org/wiki/Merge_sort)

<br>

### 8.桶排序

> 桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序. 当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（*O(n)*）。但桶排序并不是比较排序，他不受到 *O(nlogn)* 下限的影响- [1]

桶排序以下列程序进行：
- 1.设置一个定量的数组当作空桶子。
- 2.寻访序列，并且把项目一个一个放到对应的桶子去。
- 3.对每个不是空的桶子进行排序。
- 4.从不是空的桶子里把项目再放回原来的序列中。

排序过程如下：
- 元素分配到桶中

<img src='resource/sorting/img_07.svg'>

- 对桶中元素排序

<img src='resource/sorting/img_08.svg'>

参考资料：
- [1] [Bucket sort](https://en.wikipedia.org/wiki/Bucket_sort)

<br>

### 9.计数排序


> 计数排序（Counting sort）是一种稳定的线性时间排序算法。该算法于1954年由 Harold H. Seward 提出。计数排序使用一个额外的数组{\displaystyle C} C ，其中第i个元素是待排序数组{\displaystyle A}A中值等于{\displaystyle i}i的元素的个数。然后根据数组{\displaystyle C} C 来将{\displaystyle A}A中的元素排到正确的位置。


参考资料：
- [1] [Counting sort](https://en.wikipedia.org/wiki/Counting_sort)

<br>

### 分析总结
